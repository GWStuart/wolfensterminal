#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <pthread.h>
#include <netinet/in.h>
#include <netdb.h>
#include <signal.h>
#include "protocol.h"
#include <ifaddrs.h>

#define SERVER_PORT 23107

static volatile int running = 1;                                                 
static void on_sigint(int sig){
    (void)sig;
    printf("hey! you just killed the server! guess who you just made very SAD!\n");
    printf("DRRRRRRRAAATTTTTTTTT!!!!!\n");
    fflush(stdout);

    running = 0;
    exit(0);
}   


//note: this was fully generated by AI. you can tell, there's so many comments.
//the only time I do that is when I'm angry, which isn't now if you're wondering
void print_local_ip() {
    // wow this sounds hard to find out. everybody say "thank you gpt!"
    struct ifaddrs *ifaddr, *ifa;
    char host[NI_MAXHOST];

    // Get a linked list of all network interfaces
    if (getifaddrs(&ifaddr) == -1) {
        perror("getifaddrs failed");
        exit(1);
    }

    // Loop through each network interface
    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
        // Check if this is an IPv4 address and the interface is up (family AF_INET)
        if (ifa->ifa_addr->sa_family == AF_INET) {
            // Get the IP address
            if (getnameinfo(ifa->ifa_addr, sizeof(struct sockaddr_in), host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST) == 0) {
                // Print the IP address of the local machine
                if (strcmp(ifa->ifa_name, "lo") != 0) { // Exclude loopback interface "lo"
                    printf("Local IP Address (use this to connect in client): %s\n", host);
                    break; // We only need the first valid network interface (typically the active one)
                }
            }
        }
    }

    freeifaddrs(ifaddr);  // Don't forget to free the linked list
}

int listen_on_port(int port){
    int listenfd = socket(AF_INET, SOCK_DGRAM, 0); 
    if (listenfd < 0) {
	perror("fd is gone to sleep");
        exit(-1);
    }
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET; //IPv4
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(port);
    // Bind socket to address
    if (bind(listenfd, (const struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
	perror("fass bind failed\n");
	close(listenfd);
        exit(-1);
    }

    printf("UDP connection on Port %d\n", port);
    return listenfd;
   }



int main(){
    signal(SIGINT, on_sigint);
    int sockfd = listen_on_port(SERVER_PORT);
    print_local_ip();

    Player players[MAX_PLAYERS] = {0};
    uint8_t mapBytes[MAX_MAP_BYTES];
    const char *mapStr = "########\n#......#\n#..##..#\n#......#\n########\n";
    size_t mapSize = strlen(mapStr);
    if(mapSize > MAX_MAP_BYTES) {
	mapSize = MAX_MAP_BYTES;
    }
    memcpy(mapBytes, mapStr, mapSize);
    while (running){
	struct sockaddr_in clientaddr; socklen_t alen = sizeof(clientaddr);
	MessageHeader hdr;                    
	uint8_t payload[65507];
	int datasz = recv_message(sockfd, &hdr, payload, sizeof(payload), &clientaddr, &alen);
	if (datasz < 0) continue; // ignore malformed 
	    uint8_t opcode = hdr.operation;    
	    uint8_t cli_id = hdr.id;
	    if (opcode == CLIENT_HELLO){
	     if ((size_t)datasz < sizeof(Player)) continue;
	     Player incoming;
	     memcpy(&incoming, payload, sizeof(Player));
	     int slot = -1;
	     for (int i=0;i<MAX_PLAYERS;i++){
		 if (!players[i].in_use){
		     slot = i;
		     break;
		 }
	     }
	     if (slot < 0){ 
		(void)send_message(sockfd, &clientaddr, alen, SERVER_SNAPSHOT, 0xFF, NULL, 0);
		continue;
	    } 
	    players[slot] = incoming; 
	    players[slot].pdata.id = (uint8_t)slot;
	    players[slot].addr = clientaddr;
	    players[slot].in_use = 1;
	    WelcomePayload wp = {0};
	    wp.assigned_id = (uint8_t)slot;
	    wp.map_size = (uint16_t)mapSize;
	    memcpy(wp.map_bytes, mapBytes, mapSize); 
	    send_message(sockfd, &clientaddr, alen, SERVER_WELCOME, wp.assigned_id, &wp, sizeof(uint8_t)+sizeof(uint16_t)+mapSize);
	    printf("Player %d connected from %s:%d\n", slot, inet_ntoa(clientaddr.sin_addr), ntohs(clientaddr.sin_port));
	  } 
	  else if (opcode == CLIENT_UPDATE){
	      if (cli_id >= MAX_PLAYERS || !players[cli_id].in_use) continue;
	      if ((size_t)datasz < sizeof(Player)) continue;
	      Player updated;
	      memcpy(&updated, payload, sizeof(Player));
	      players[cli_id].pdata = updated.pdata;
	      players[cli_id].speed = updated.speed;
	      players[cli_id].health = updated.health;
	      players[cli_id].addr = clientaddr;
	      Public pubs[MAX_PLAYERS];
	      size_t n = build_public_snapshot(players, MAX_PLAYERS, cli_id, pubs, MAX_PLAYERS);
	      uint16_t count = (uint16_t)n;
	      size_t bytes = sizeof(count) + n*sizeof(Public);
	      uint8_t *buf = (uint8_t*)malloc(bytes);
	      memcpy(buf, &count, sizeof(count));
	      memcpy(buf+sizeof(count), pubs, n*sizeof(Public));
	      send_message(sockfd, &clientaddr, alen, SERVER_SNAPSHOT, cli_id, buf, (uint32_t)bytes);
	      free(buf);
	} else if (opcode == CLIENT_DISCONNECT) {
	    uint8_t id = cli_id;
	    if(id < MAX_PLAYERS) {
		players[id].in_use = 0;
		printf("Player %d disconnected\n", id);
		}
	    }
    }
    close(sockfd);
    
    return 0;

}
    
